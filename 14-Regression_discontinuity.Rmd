---
output:
  pdf_document: default
  html_document: default
---
#	Alternatives to RCT: regression discontinuity

The regression discontinuity follows a quasi-experimental design and is typically used to avoid confounding bias (i.e. when another variable is present that distorts the effect of intervention) when assesssing interventions. It is particularly useful when assignment to intervention is based on some pre-specified threshold from a continuous measure. For example, let us assume that we wish to assess a new reading intervention in a school. Students are assigned to the intervention group according to a general language test. Students that score below a certain threshold are assigned to the intervention group, and rather than discrd their peers that scored above the threshold, they forma natural control group. The experimenter is not therefore required to randomly allocate students with poor language scores to the control group when they might benefit from the potential effect of the intervention if it is found to be effective.

Before we delve into the regression discontinuity designs, it may be useful for us to first take a look at general linear models, in particular, ordinary linear regression. Linear models consist of some of the most commonly used methods in applied research including ANOVA, ANCOVA, linear regression, t-tests, F-tests and MANCOVA.

Linear regression's purpose is primarily to understand the straight line relationship that exists for some bivariate data. We assume a causal direction  inthe relationship unlike correlation as we specify an outcome (dependent) variable and a predictor (independent) variable. The idea being that as we change the value of predictor we see the effect that this has on the outcome variable, by quantifying the relationship according to some statistical model. Figure \@ref(fig:linReg) (A, left) shows some bivariate data which appears to have an underlying linear relationship 

```{r linReg, echo=F, message=F, warning=F, fig.width=8,fig.height=4, fig.cap="Linear regression: Plotting residuals, intercept, and slope explainers "}
# list_of_packages<-c("tidyverse","stats","ggpubr","rddapp","grid","pBrackets","diagram")
# new.packages <- list_of_packages[!(list_of_packages %in% installed.packages()[,"Package"])]
# if(length(new.packages))install.packages(new.packages,dependencies = TRUE)

library(tidyverse)
library(stats)
library(ggpubr)
library(grid)
library(pBrackets) 
library(diagram)

#simulate some data based on a known structure
set.seed(123)
b0 = 0.1
b1=1.2
err<-rnorm(30,0,1)

x<-runif(30,1,5)
y<-b0+b1*x+err

data.lm <- data.frame(y=y,x=x)
mylm1 <- lm(y ~ x, data = data.lm)


## Get the residuals and predicted values
data.lm$pred <- predict(mylm1)
data.lm$resid <- residuals(mylm1)

## Compute densities for residuals.

    d <- density(data.lm$resid)
    residuals <- data.frame(x=max(data.lm$x)- d$y, y=d$x+mean(data.lm$y))
    residuals <- residuals[order(residuals$y), ]
    myx <- seq(min(data.lm$resid), max(data.lm$resid),length=100)
    residuals <- data.frame(y=myx + tail(sort(fitted.values(mylm1)),1), x=max(data.lm$x) - 2*dnorm(myx, 0, sd(data.lm$resid)))
    

g1<-ggplot(data.lm, aes(x = x, y = y)) +
  geom_segment(aes(x=2,y=(b0+b1*(2)),xend = 3, yend = (b0+b1*(2))),col="blue",linetype="dashed",size=1) +
  geom_segment(aes(x=3,y=(b0+b1*(2)),xend = 3, yend = (b0+b1*(3))),col="blue",linetype="dashed",size=1)+
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  geom_point(alpha = 0.25) +  # Alpha mapped to abs(residuals)
  guides(alpha = FALSE) + theme_bw()+xlab("Predictor")+ylab("Outcome")+
  geom_path(data=residuals, aes(x, y)) + geom_vline(xintercept=max(residuals$x), lty=2)+
  geom_polygon(data=residuals,alpha=0.1)


g2<-ggplot(data.lm, aes(x = x, y = y)) +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  geom_segment(aes(xend = x, yend = pred), alpha = .2) +
  geom_point(alpha = 0.25) +  
  guides(alpha = FALSE) + theme_bw()+xlab("Predictor")+ylab("Outcome")

ggarrange(g1,g2,nrow=1,ncol=2,labels = c("A", "B"))

```


$$Y_{i} = \beta_{0} +  \beta_{1}X_{i,1} + \beta_{2}X_{i,2} + \beta_{3}(X_{i,1} >= c) $$

where 

Statistical issues encountered RDD analysis:

 1. Incorrect specification of regression form ( regression is non-linear or needs a polynomial form)
 2. Misallocation of treatment
 3. Inadequate statistical power (sample size too small)
 4. Limited generalization of effects

```{r linRegDis, echo=F, message=F, warning=F, fig.width=6,fig.height=5, fig.cap="Linear regression: Plotting residuals, intercept, and slope explainers "}

#simulate some data based on a known structure
set.seed(123)
dat <- data.frame(x = runif(100, 1, 3), x2 = rnorm(100,0,0.25))
dat$intervention <- as.factor(as.integer(dat$x >= 2))
dat$rev_intervention <- as.factor(as.integer(dat$x < 2))
dat$y <- 3 + 2 * dat$x + 2 * dat$x2 + 4 * (dat$x >= 2) + rnorm(100,0,0.5)

newdat1<-dat[dat$intervention==0,]
newdat2<-dat[dat$intervention==1,]

mod1 <- lm(y~x,newdat1)
mod2 <- lm(y~x,newdat2)
 #plots for lmer


 ggplot(dat, aes(x = x, y = y)) + 
   geom_point(alpha=0.35,aes(color=intervention)) + 
   geom_vline(xintercept = 2, color = 'grey', size = 1, linetype = 'dashed') + 
   geom_line(data=newdat1,aes(y=predict(mod1,newdata=newdat1),color=intervention),size = .75)+
   geom_line(data=newdat2,aes(y=predict(mod2,newdata=newdat2),color=intervention),size = .75)+
   geom_line(data=newdat2,aes(y=predict(mod1,newdata=newdat2),color=rev_intervention),size = .75,linetype="dashed")+
   geom_line(data=newdat1,aes(y=predict(mod2,newdata=newdat1),color=rev_intervention),size = .75,linetype="dashed")+
   theme_bw()+ theme(legend.position = "none",strip.text=element_text(size=12),axis.text=element_text(size=12),axis.title=element_text(size=12,face="bold"))+ annotate("text",x=2.3,y=9,label="Intervention \neffect size")+xlab("Predictor")+ylab("Outcome") +
   annotate("text",x=1.5,y=14,label="Control") +
   annotate("text",x=2.5,y=14,label="Intervention")

grid.brackets(235, 122, 235, 220, lwd=2, col="black")
#https://stackoverflow.com/questions/7001799/ggplot2-curly-braces-on-an-axis/33544572

# library(rddapp)  #cite example directly from R package
# dat <- data.frame(x = runif(1000, -1, 1), cov = rnorm(1000))
# dat$tr <- as.integer(dat$x >= 0)
# dat$y <- 3 + 2 * dat$x + 3 * dat$cov + 10 * (dat$x >= 0) + rnorm(1000)
# rd <- rd_est(y ~ x + tr | cov, data = dat, cutpoint = 0, t.design = "geq")
# plot(rd)
```

## Mediators

```{r mediator,echo=F,warning=F,message=F,fig.cap="Mediator path diagram"}
library(diagram)
data <- c(0, "' '", 0,
          0, 0, 0, 
          "' '", "' '", 0)
M<- matrix (nrow=3, ncol=3, byrow = TRUE, data=data)
plot<- plotmat (M, pos=c(1,2), 
                name= c( "Mediator (M)","Predictor (X)", "Outcome (Y)"), 
                box.type = "rect", box.size = 0.12, box.prop=0.5,  curve=0)
```


## Moderators


```{r moderator,echo=F,warning=F,message=F,fig.cap="Moderator path diagram"}
library(diagram)
data <- c(0, 0, 0,
          0, 0, 0, 
          0, "' '", 0)
M<- matrix (nrow=3, ncol=3, byrow = TRUE, data=data)
plot2<- plotmat (M, pos=c(1,2), 
                name= c( "Moderator (M)","Predictor (X)", "Outcome(Y)"), 
                box.type = "rect", box.size = 0.12, box.prop=0.5,  curve=0,arr.pos = 0.6)

Moderator <- plot2$comp[1,]
Predictor <- plot2$comp[2,]
Outcome <- plot2$comp[3,]

m2 <- 0.5*(Predictor+Outcome)
 m1 <- Moderator
 m1[2] <- m1[2] - plot2$radii[2,1]
 mid <- straightarrow (to = m2, from = m1, arr.type = "triangle",
 arr.pos = 0.5, lwd = 1)
```

If we return to our linear regression definition from earlier, we have some predictor variable $X$ that has a linear causal relationship with $Y$, i.e. $X$ causes $Y$. Moderation occurs when a third variable is introduced, say $M$ that changes the strength of causal relationship between $X$ and $Y$, hence moderating the relationship.

Figure \@ref(fig:moderator) shows a disgrammatic representation of the moderator effect. The moderator is added into the statistical framework as an interaction. The interaction is added into the regression model formula as an extra variable with a new associated parameter estimate. The extra variable is simple the two interacting terms multiplied together. We can give an exmaple of this by returning to the regression equation that we met earlier. The interaction appears as the multiple of $X_{1}$ and $X_{2}$. 


$$Y_{i} = \beta_{0} +  \beta_{1}X_{i,1} + \beta_{2}X_{i,2} + \beta_{3}(X_{i,1}X_{i,2})$$


We can visual the effect of the interaction much more clearly by looking at some simulated data. Plotting the data, for two types of combinations of variables. Figure \@ref(fig:interaction)A (LEFT) shows the relationship between a nominal Moderator and a continuous predictor. Figure \@ref(fig:interaction)B (RIGHT) shows the relationship between a nominal Moderator and a nominal predictor. 

```{r interaction,echo=F,message=F,warning=F,fig.cap="Plotting the interaction effect in regression. (A) shows the relation between a nominal Moderator and continuous predictor; (B) shows the relationship between a nominal Moderator and nominal predictor."}

#simulate some data based on a known structure
set.seed(123)
b0a = 0.1
b1a=1.2
b0b = 4
b1b=0.2
err<-rnorm(100,0,1)

x<-runif(100,1,5)
y[1:50]<-b0a+b1a*x[1:50]+err[1:50]
y[51:100]<-b0b+b1b*x[51:100]+err[51:100]                 

data.lm <- data.frame(y=y,x=x)
mylm1 <- lm(y ~ x, data = data.lm)

data.lm$Moderator2<-factor(c(rep("A",50),rep("B",50)))

inter1 <- ggplot(data.lm, aes(x = x, y = y,colour=Moderator2)) +
geom_smooth(method = "lm", se = FALSE) +
geom_point(alpha = 0.35) +  
guides(alpha = FALSE) + theme_bw()+xlab("Predictor")+ylab("Outcome")+theme(legend.title = element_blank(),legend.position="bottom")

####

set.seed(123)
#
b0c <- 1.3
b1c <- 1.6
b2c <- -0.75
b3c <- 1.95
#
Moderator1 <- sample(c(0,1),100,prob=c(0.5,0.5),replace=T)
Moderator2 <- sample(c(0,1),100,prob=c(0.5,0.5),replace=T)
#  
err<-rnorm(100,0,1)
#
y<-b0c+b1c*Moderator1+b2c*Moderator2+b3c*Moderator1*Moderator2+err
#

#
data.lm2 <- data.frame(y=y,Moderator1=Moderator1,Moderator2=Moderator2)
data.lm2$Moderator2<-factor(data.lm2$Moderator2)
levels(data.lm2$Moderator2) <- c("A","B")
#########

inter2<-ggplot(data.lm2, aes(x = factor(Moderator1), y = y, color = Moderator2,group=Moderator2)) +
geom_point(alpha=0.2) + stat_summary(fun.y=mean,geom="point",size=2.5) + stat_summary(fun.y=mean,geom="line") + theme_bw() + theme(legend.title = element_blank(),legend.position="bottom") + xlab("Predictor") + ylab("Mean of Outcome")
  

ggarrange(inter1,inter2,ncol=2,nrow=1,common.legend = TRUE,labels=c("A","B"),legend="bottom")
    
```




